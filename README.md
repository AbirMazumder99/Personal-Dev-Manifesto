# Personal-Dev-Manifesto

Personal Dev Notes for the future

## Software Architecture Considerations

- Implementation details: folder structure
- Implementation design: Client Side Rendering vs Server Side Rendering, Relational vs Non-Relational Database
- Technologies: REST vs GraphQL for API, Python w Django vs Node w Express for backend
- System design: Monolith vs Microservices
- Infrastructure: On Premises vs Cloud

## Project Planning

- Sprint Board: GitHub Projects/ Jira
- Project Documentation: Confluence/ Notion

## Design

- Figma

## Web Application Framework

- Model-View-Controller (MVC)

## Infrastructure as Code (IaC)

- Terraform

## CI/CD Pipeline

- Github Actions

# Knowing what to include in .gitignore

- OS Specific files: .DS_Store
- IDE configuration files: .json
- Compiled Object Files/ Binaries: .o
- Folders generated by Package Managers: ./node_modules
- files with sensitive info such as API keys: .env
- Runtime files: .log

## Environments

- development/integration
- staging/QA
- production

## API Testing

- Testing Endpoints: Postman
- Declarative API Documentation: Swagger

## End-to-end Testing

- Docker: provision infrastructure resources and mimic a prod environment in isolation
- Selenium: Utilize the WebDriver API to automate events for web apps

## Web dev Project Workflow

1. Create the GitHub repo with the project skeleton and push the initial code
2. Set up GitHub continuous deployment with Vercel/Netlify (or any other hosting service)
3. Create branches in the repository to implement features or fix bugs
4. Hosting services will create a deployable build, deploy it on a CDN, and provide us a preview URL for each branch
5. Use this URL to test the feature. We can also share this URL publicly with our stakeholders
6. Merge the PR, and the changes in the master or main branch are also built and deployed automatically

## Git Commit Types

- feat – feature addition
- fix – bug fix
- chore – improvements/ tech debt
- refactor – improvements/ tech debt
- docs – documentation
- style – code format
- test – including new or correcting previous tests
- perf – performance improvements
- ci – continuous integration related
- build – changes that affect the build system or external dependencies
- revert – reverts a previous commit

## General Project Structure

```
└─── .github/workflows: CI/CD with Github Actions
└─── src/: Frontend
└─── api/: Backend
└─── infrastructure: Cloud Resource Provisioning
```

## React Best Practices (adapt as per application size)

- kebab-case naming convention for folders: message-item/
- Maintainable import structure at the top of files: Built-In (like 'react') --> External (third-party node modules) --> Internal

- Set up Linter (ESLint)
- Lazy loading/ Code Splitting for better bundle management (WebPack)
- Error Handling (try/catch, react-error-boundary library as appropriate, 3rd Party/ custom logging utilities)
- useReducer hook for components where useState hooks > 4 for better code readability
- Folder Structure

```
src
└───feature (Non-reusable Components)
    └───user/
    └───message/
        └───message-item/
        └───message-list/
    └───payment/
└───components (Reusable Components)
    └───app/
    │       App.js
    |       App.test.js
    │       App.style.css
    └───button/
    └───list/
└───hooks/
└───context/
└───services/
```

## VSCode Extensions

- GitLens
- Live Share
- Better Comments
- Prettier
- ESLint
- IntelliCode + API Usage Examples

## Data Visualization

- Charts - JSCharting

## Useful Notes

- Sometimes it will required to delete ./node_modules folder to resolve random errors related to 3rd party libraries. Use the following command instead of manual deletion because it will be way faster
  ```
  rm -rf node_modules
  ```
- When concerned with caching for better performance, memoization is a good concept to implement

## Useful GitHub Repo

- https://github.com/donnemartin/system-design-primer
- https://12factor.net/
- https://web.dev/

## Projects

- Revamp Personal Website w an overall theme of music
- MyMeme Website
- Shane Watson

## Data Engineering in a Project Context

- SWE Basics: terminal, YAML files, Git/GitHub
- Programming: SQL basics
- Data Warehouse: BigQuery (Dataset, Table, Service Accounts) & appropriate alternatives
- Data Processing: DBT CLI commands
- CI/CD: GitHub Actions, Docker
- Dashboarding: Connect to data, create charts/metrics

## Understanding New Codebase Best Practices

- Environment Setup
- Build Process
- Debug Code to understand stack tracing and flow
- Deployment
- Use the application
- Documentation (README.md, Notion, Confluence)
- Dependencies
  - External: DB, Caching, Other Microservices (.env files are helpful for this)
  - Internal: JS/ Python libraries; usually managed via package manager like npm (package.json) or poetry (pyproject.toml)
- Data model (a tool like DBeaver shows schemas and relations)

## Data Engineering Stuff

Good guide: https://github.com/andkret/Cookbook

AWS Data Pipeline Blueprint

1. Connect (AWS API Gateway)
2. Store (AWS S3, DynamoDB)
3. Processing Framework (AWS ElasticSearch)
4. Buffer (AWS Kinesis)
5. Visualize (Web & Mobile Apps, BI Tools like Tablueu)

## Engineering Competency

https://docs.google.com/spreadsheets/d/131XZCEb8LoXqy79WWrhCX4sBnGhCM1nAIz4feFZJsEo/edit#gid=0

## Starred Repos

https://github.com/npmaile/blog
